#include <iostream>
#include <array>
#include <queue>
#define INF 0x3fffffff

using namespace std;

const int MAXN = 500;
int n, m, s, e;
array <int, MAXN> dist;
array <int, MAXN> expe;
array < array<pair<int, int>, MAXN>, MAXN> adjMatrix;
array <bool, MAXN> collected;

void Init( );
void Dijkstra(int s);
int FindMin(int s);
void Print( );

int main()
{
    Init();
    Dijkstra(s);
    Print( );
    return 0;
}

void Init( )
{
      cin >>  n >> m >> s >> e;
    int city1, city2, distance, expense;

    fill(dist.begin(), dist.end(), INF);
    fill(expe.begin(), expe.end(), INF);
    fill(collected.begin(), collected.end(), false);
    for (int i = 0; i < n; ++ i) {
        for (int j = 0; j < n; ++ j ) {
            adjMatrix[i][j].first = INF;
            adjMatrix[i][j].second = INF;
        }
    }
    for (int i = 0; i < m; ++ i) {
        cin >> city1 >> city2;
        cin >> distance >> expense;
        adjMatrix[city1][city2].first = adjMatrix[city2][city1].first = distance;
        adjMatrix[city1][city2].second = adjMatrix[city2][city1].second = expense;
    }
    for (int i = 0; i < n; ++ i) {
        dist[i] = adjMatrix[s][i].first;
        expe[i] = adjMatrix[s][i].second;
    }
//    for (int i = 0; i < n; ++ i) {
//        for (int j = 0; j < n; ++ j) {
//            printf("%d ", adjMatrix[i][j].first);
//        }
//        cout << endl;
//    }
}
void Dijkstra(int s)
{
    queue <int> q;
    q.push(s);
    collected[s] = true;
    dist[s] = 0, expe[s] = 0;
    while (!q.empty()) {
        int tmp = FindMin(s);
        if (tmp == -1 ) break;
        collected[tmp] = true;
        for (int i = 0; i < n; ++ i) {
            if (!collected[i] && adjMatrix[tmp][i].first != INF ) {
                if(dist[tmp] + adjMatrix[tmp][i].first < dist[i]) {
                    dist[i] = dist[tmp] + adjMatrix[tmp][i].first;
                    expe[i] = expe[tmp] + adjMatrix[tmp][i].second;
                }
                else if ( (dist[tmp] + adjMatrix[tmp][i].first == dist[i]) && (expe[tmp] + adjMatrix[tmp][i].second < expe[i]) ) {
                    expe[i] = expe[tmp] + adjMatrix[tmp][i].second;
                }
            }
        }
    }
}

int FindMin(int s)
{
    int minDist {INF};
    int minV {-1};
    for (int i = 0; i < n; ++ i) {
        if (!collected[i] && dist[i] < minDist) {
            minDist = dist[i];
            minV = i;
        }
    }
    return minV;
}
void Print( )
{
    printf("%d %d\n",dist[e], expe[e]);
}
